'\" t
.\"     Title: zmq_setsockopt
.\"    Author: [see the "AUTHORS" section]
.\" Generator: DocBook XSL Stylesheets v1.76.1 <http://docbook.sf.net/>
.\"      Date: 11/03/2014
.\"    Manual: 0MQ Manual
.\"    Source: 0MQ 4.1.0
.\"  Language: English
.\"
.TH "ZMQ_SETSOCKOPT" "3" "11/03/2014" "0MQ 4\&.1\&.0" "0MQ Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
zmq_setsockopt \- set 0MQ socket options
.SH "SYNOPSIS"
.sp
\fBint zmq_setsockopt (void \fR\fB\fI*socket\fR\fR\fB, int \fR\fB\fIoption_name\fR\fR\fB, const void \fR\fB\fI*option_value\fR\fR\fB, size_t \fR\fB\fIoption_len\fR\fR\fB);\fR
.sp
Caution: All options, with the exception of ZMQ_SUBSCRIBE, ZMQ_UNSUBSCRIBE, ZMQ_LINGER, ZMQ_ROUTER_HANDOVER, ZMQ_ROUTER_MANDATORY, ZMQ_PROBE_ROUTER, ZMQ_XPUB_VERBOSE, ZMQ_REQ_CORRELATE, and ZMQ_REQ_RELAXED, only take effect for subsequent socket bind/connects\&.
.sp
Specifically, security options take effect for subsequent bind/connect calls, and can be changed at any time to affect subsequent binds and/or connects\&.
.SH "DESCRIPTION"
.sp
The \fIzmq_setsockopt()\fR function shall set the option specified by the \fIoption_name\fR argument to the value pointed to by the \fIoption_value\fR argument for the 0MQ socket pointed to by the \fIsocket\fR argument\&. The \fIoption_len\fR argument is the size of the option value in bytes\&.
.sp
The following socket options can be set with the \fIzmq_setsockopt()\fR function:
.SS "ZMQ_AFFINITY: Set I/O thread affinity"
.sp
The \fIZMQ_AFFINITY\fR option shall set the I/O thread affinity for newly created connections on the specified \fIsocket\fR\&.
.sp
Affinity determines which threads from the 0MQ I/O thread pool associated with the socket\(cqs \fIcontext\fR shall handle newly created connections\&. A value of zero specifies no affinity, meaning that work shall be distributed fairly among all 0MQ I/O threads in the thread pool\&. For non\-zero values, the lowest bit corresponds to thread 1, second lowest bit to thread 2 and so on\&. For example, a value of 3 specifies that subsequent connections on \fIsocket\fR shall be handled exclusively by I/O threads 1 and 2\&.
.sp
See also \fBzmq_init\fR(3) for details on allocating the number of I/O threads for a specific \fIcontext\fR\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
uint64_t
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A (bitmap)
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
N/A
T}
.TE
.sp 1
.SS "ZMQ_BACKLOG: Set maximum length of the queue of outstanding connections"
.sp
The \fIZMQ_BACKLOG\fR option shall set the maximum length of the queue of outstanding peer connections for the specified \fIsocket\fR; this only applies to connection\-oriented transports\&. For details refer to your operating system documentation for the \fIlisten\fR function\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
connections
T}
T{
.sp
Default value
T}:T{
.sp
100
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, only for connection\-oriented transports\&.
T}
.TE
.sp 1
.SS "ZMQ_CONNECT_RID: Assign the next outbound connection id"
.sp
The \fIZMQ_CONNECT_RID\fR option sets the peer id of the next host connected via the zmq_connect() call, and immediately readies that connection for data transfer with the named id\&. This option applies only to the first subsequent call to zmq_connect(), calls thereafter use default connection behavior\&.
.sp
Typical use is to set this socket option ahead of each zmq_connect() attempt to a new host\&. Each connection MUST be assigned a unique name\&. Assigning a name that is already in use is not allowed\&.
.sp
Useful when connecting ROUTER to ROUTER, or STREAM to STREAM, as it allows for immediate sending to peers\&. Outbound id framing requirements for ROUTER and STREAM sockets apply\&.
.sp
The peer id should be from 1 to 255 bytes long and MAY NOT start with binary zero\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
NULL
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_ROUTER, ZMQ_STREAM
T}
.TE
.sp 1
.SS "ZMQ_CONFLATE: Keep only last message"
.sp
If set, a socket shall keep only one message in its inbound/outbound queue, this message being the last message received/the last message to be sent\&. Ignores \fIZMQ_RCVHWM\fR and \fIZMQ_SNDHWM\fR options\&. Does not support multi\-part messages, in particular, only one part of it is kept in the socket internal queue\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
boolean
T}
T{
.sp
Default value
T}:T{
.sp
0 (false)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_PULL, ZMQ_PUSH, ZMQ_SUB, ZMQ_PUB, ZMQ_DEALER
T}
.TE
.sp 1
.SS "ZMQ_CURVE_PUBLICKEY: Set CURVE public key"
.sp
Sets the socket\(cqs long term public key\&. You must set this on CURVE client sockets, see \fBzmq_curve\fR(7)\&. You can provide the key as 32 binary bytes, or as a 40\-character string encoded in the Z85 encoding format and terminated in a null byte\&. The public key must always be used with the matching secret key\&. To generate a public/secret key pair, use \fBzmq_curve_keypair\fR(3)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
an option value size of 40 is supported for backwards compatibility, though is deprecated\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data or Z85 text string
T}
T{
.sp
Option value size
T}:T{
.sp
32 or 41
T}
T{
.sp
Default value
T}:T{
.sp
NULL
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_CURVE_SECRETKEY: Set CURVE secret key"
.sp
Sets the socket\(cqs long term secret key\&. You must set this on both CURVE client and server sockets, see \fBzmq_curve\fR(7)\&. You can provide the key as 32 binary bytes, or as a 40\-character string encoded in the Z85 encoding format and terminated in a null byte\&. To generate a public/secret key pair, use \fBzmq_curve_keypair\fR(3)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
an option value size of 40 is supported for backwards compatibility, though is deprecated\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data or Z85 text string
T}
T{
.sp
Option value size
T}:T{
.sp
32 or 41
T}
T{
.sp
Default value
T}:T{
.sp
NULL
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_CURVE_SERVER: Set CURVE server role"
.sp
Defines whether the socket will act as server for CURVE security, see \fBzmq_curve\fR(7)\&. A value of \fI1\fR means the socket will act as CURVE server\&. A value of \fI0\fR means the socket will not act as CURVE server, and its security role then depends on other option settings\&. Setting this to \fI0\fR shall reset the socket security to NULL\&. When you set this you must also set the server\(cqs secret key using the ZMQ_CURVE_SECRETKEY option\&. A server socket does not need to know its own public key\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_CURVE_SERVERKEY: Set CURVE server key"
.sp
Sets the socket\(cqs long term server key\&. You must set this on CURVE client sockets, see \fBzmq_curve\fR(7)\&. You can provide the key as 32 binary bytes, or as a 40\-character string encoded in the Z85 encoding format and terminated in a null byte\&. This key must have been generated together with the server\(cqs secret key\&. To generate a public/secret key pair, use \fBzmq_curve_keypair\fR(3)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
an option value size of 40 is supported for backwards compatibility, though is deprecated\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data or Z85 text string
T}
T{
.sp
Option value size
T}:T{
.sp
32 or 41
T}
T{
.sp
Default value
T}:T{
.sp
NULL
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_GSSAPI_PLAINTEXT: Disable GSSAPI encryption"
.sp
Defines whether communications on the socket will encrypted, see \fBzmq_gssapi\fR(7)\&. A value of \fI1\fR means that communications will be plaintext\&. A value of \fI0\fR means communications will be encrypted\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0 (false)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_GSSAPI_PRINCIPAL: Set name of GSSAPI principal"
.sp
Sets the name of the pricipal for whom GSSAPI credentials should be acquired\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
character string
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
not set
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_GSSAPI_SERVER: Set GSSAPI server role"
.sp
Defines whether the socket will act as server for GSSAPI security, see \fBzmq_gssapi\fR(7)\&. A value of \fI1\fR means the socket will act as GSSAPI server\&. A value of \fI0\fR means the socket will act as GSSAPI client\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0 (false)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_GSSAPI_SERVICE_PRINCIPAL: Set name of GSSAPI service principal"
.sp
Sets the name of the pricipal of the GSSAPI server to which a GSSAPI client intends to connect\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
character string
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
not set
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_HANDSHAKE_IVL: Set maximum handshake interval"
.sp
The \fIZMQ_HANDSHAKE_IVL\fR option shall set the maximum handshake interval for the specified \fIsocket\fR\&. Handshaking is the exchange of socket configuration information (socket type, identity, security) that occurs when a connection is first opened, only for connection\-oriented transports\&. If handshaking does not complete within the configured time, the connection shall be closed\&. The value 0 means no handshake time limit\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
30000
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all but ZMQ_STREAM, only for connection\-oriented transports
T}
.TE
.sp 1
.SS "ZMQ_IDENTITY: Set socket identity"
.sp
The \fIZMQ_IDENTITY\fR option shall set the identity of the specified \fIsocket\fR when connecting to a ROUTER socket\&. The identity should be from 1 to 255 bytes long and may contain any values\&.
.sp
If two clients use the same identity when connecting to a ROUTER, the results shall depend on the ZMQ_ROUTER_HANDOVER option setting\&. If that is not set (or set to the default of zero), the ROUTER socket shall reject clients trying to connect with an already\-used identity\&. If that option is set to 1, the ROUTER socket shall hand\-over the connection to the new client and disconnect the existing one\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
NULL
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_REQ, ZMQ_REP, ZMQ_ROUTER, ZMQ_DEALER\&.
T}
.TE
.sp 1
.SS "ZMQ_IMMEDIATE: Queue messages only to completed connections"
.sp
By default queues will fill on outgoing connections even if the connection has not completed\&. This can lead to "lost" messages on sockets with round\-robin routing (REQ, PUSH, DEALER)\&. If this option is set to 1, messages shall be queued only to completed connections\&. This will cause the socket to block if there are no other connections, but will prevent queues from filling on pipes awaiting connection\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
boolean
T}
T{
.sp
Default value
T}:T{
.sp
0 (false)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, only for connection\-oriented transports\&.
T}
.TE
.sp 1
.SS "ZMQ_IPV6: Enable IPv6 on socket"
.sp
Set the IPv6 option for the socket\&. A value of 1 means IPv6 is enabled on the socket, while 0 means the socket will use only IPv4\&. When IPv6 is enabled the socket will connect to, or accept connections from, both IPv4 and IPv6 hosts\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
boolean
T}
T{
.sp
Default value
T}:T{
.sp
0 (false)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_LINGER: Set linger period for socket shutdown"
.sp
The \fIZMQ_LINGER\fR option shall set the linger period for the specified \fIsocket\fR\&. The linger period determines how long pending messages which have yet to be sent to a peer shall linger in memory after a socket is disconnected with \fBzmq_disconnect\fR(3) or closed with \fBzmq_close\fR(3), and further affects the termination of the socket\(cqs context with \fBzmq_term\fR(3)\&. The following outlines the different behaviours:
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The default value of
\fI\-1\fR
specifies an infinite linger period\&. Pending messages shall not be discarded after a call to
\fIzmq_disconnect()\fR
or
\fIzmq_close()\fR; attempting to terminate the socket\(cqs context with
\fIzmq_term()\fR
shall block until all pending messages have been sent to a peer\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
The value of
\fI0\fR
specifies no linger period\&. Pending messages shall be discarded immediately after a call to
\fIzmq_disconnect()\fR
or
\fIzmq_close()\fR\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04'\(bu\h'+03'\c
.\}
.el \{\
.sp -1
.IP \(bu 2.3
.\}
Positive values specify an upper bound for the linger period in milliseconds\&. Pending messages shall not be discarded after a call to
\fIzmq_disconnect()\fR
or
\fIzmq_close()\fR; attempting to terminate the socket\(cqs context with
\fIzmq_term()\fR
shall block until either all pending messages have been sent to a peer, or the linger period expires, after which any pending messages shall be discarded\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
Option value type
T}:T{
int
T}
T{
Option value unit
T}:T{
milliseconds
T}
T{
Default value
T}:T{
\-1 (infinite)
T}
T{
Applicable socket types
T}:T{
all
T}
.TE
.sp 1
.RE
.SS "ZMQ_MAXMSGSIZE: Maximum acceptable inbound message size"
.sp
Limits the size of the inbound message\&. If a peer sends a message larger than ZMQ_MAXMSGSIZE it is disconnected\&. Value of \-1 means \fIno limit\fR\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int64_t
T}
T{
.sp
Option value unit
T}:T{
.sp
bytes
T}
T{
.sp
Default value
T}:T{
.sp
\-1
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all
T}
.TE
.sp 1
.SS "ZMQ_MULTICAST_HOPS: Maximum network hops for multicast packets"
.sp
Sets the time\-to\-live field in every multicast packet sent from this socket\&. The default is 1 which means that the multicast packets don\(cqt leave the local network\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
network hops
T}
T{
.sp
Default value
T}:T{
.sp
1
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using multicast transports
T}
.TE
.sp 1
.SS "ZMQ_PLAIN_PASSWORD: Set PLAIN security password"
.sp
Sets the password for outgoing connections over TCP or IPC\&. If you set this to a non\-null value, the security mechanism used for connections shall be PLAIN, see \fBzmq_plain\fR(7)\&. If you set this to a null value, the security mechanism used for connections shall be NULL, see \fBzmq_null\fR(3)\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
character string
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
not set
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_PLAIN_SERVER: Set PLAIN server role"
.sp
Defines whether the socket will act as server for PLAIN security, see \fBzmq_plain\fR(7)\&. A value of \fI1\fR means the socket will act as PLAIN server\&. A value of \fI0\fR means the socket will not act as PLAIN server, and its security role then depends on other option settings\&. Setting this to \fI0\fR shall reset the socket security to NULL\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_PLAIN_USERNAME: Set PLAIN security username"
.sp
Sets the username for outgoing connections over TCP or IPC\&. If you set this to a non\-null value, the security mechanism used for connections shall be PLAIN, see \fBzmq_plain\fR(7)\&. If you set this to a null value, the security mechanism used for connections shall be NULL, see \fBzmq_null\fR(3)\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
character string
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
not set
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_PROBE_ROUTER: bootstrap connections to ROUTER sockets"
.sp
When set to 1, the socket will automatically send an empty message when a new connection is made or accepted\&. You may set this on REQ, DEALER, or ROUTER sockets connected to a ROUTER socket\&. The application must filter such empty messages\&. The ZMQ_PROBE_ROUTER option in effect provides the ROUTER application with an event signaling the arrival of a new peer\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
do not set this option on a socket that talks to any other socket types: the results are undefined\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_ROUTER, ZMQ_DEALER, ZMQ_REQ
T}
.TE
.sp 1
.SS "ZMQ_RATE: Set multicast data rate"
.sp
The \fIZMQ_RATE\fR option shall set the maximum send or receive data rate for multicast transports such as \fBzmq_pgm\fR(7) using the specified \fIsocket\fR\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
kilobits per second
T}
T{
.sp
Default value
T}:T{
.sp
100
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using multicast transports
T}
.TE
.sp 1
.SS "ZMQ_RCVBUF: Set kernel receive buffer size"
.sp
The \fIZMQ_RCVBUF\fR option shall set the underlying kernel receive buffer size for the \fIsocket\fR to the specified size in bytes\&. A value of zero means leave the OS default unchanged\&. For details refer to your operating system documentation for the \fISO_RCVBUF\fR socket option\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
bytes
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all
T}
.TE
.sp 1
.SS "ZMQ_RCVHWM: Set high water mark for inbound messages"
.sp
The \fIZMQ_RCVHWM\fR option shall set the high water mark for inbound messages on the specified \fIsocket\fR\&. The high water mark is a hard limit on the maximum number of outstanding messages 0MQ shall queue in memory for any single peer that the specified \fIsocket\fR is communicating with\&. A value of zero means no limit\&.
.sp
If this limit has been reached the socket shall enter an exceptional state and depending on the socket type, 0MQ shall take appropriate action such as blocking or dropping sent messages\&. Refer to the individual socket descriptions in \fBzmq_socket\fR(3) for details on the exact action taken for each socket type\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
messages
T}
T{
.sp
Default value
T}:T{
.sp
1000
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all
T}
.TE
.sp 1
.SS "ZMQ_RCVTIMEO: Maximum time before a recv operation returns with EAGAIN"
.sp
Sets the timeout for receive operation on the socket\&. If the value is 0, \fIzmq_recv(3)\fR will return immediately, with a EAGAIN error if there is no message to receive\&. If the value is \-1, it will block until a message is available\&. For all other values, it will wait for a message for that amount of time before returning with an EAGAIN error\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
\-1 (infinite)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all
T}
.TE
.sp 1
.SS "ZMQ_RECONNECT_IVL: Set reconnection interval"
.sp
The \fIZMQ_RECONNECT_IVL\fR option shall set the initial reconnection interval for the specified \fIsocket\fR\&. The reconnection interval is the period 0MQ shall wait between attempts to reconnect disconnected peers when using connection\-oriented transports\&. The value \-1 means no reconnection\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
The reconnection interval may be randomized by 0MQ to prevent reconnection storms in topologies with a large number of peers per socket\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
100
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, only for connection\-oriented transports
T}
.TE
.sp 1
.SS "ZMQ_RECONNECT_IVL_MAX: Set maximum reconnection interval"
.sp
The \fIZMQ_RECONNECT_IVL_MAX\fR option shall set the maximum reconnection interval for the specified \fIsocket\fR\&. This is the maximum period 0MQ shall wait between attempts to reconnect\&. On each reconnect attempt, the previous interval shall be doubled untill ZMQ_RECONNECT_IVL_MAX is reached\&. This allows for exponential backoff strategy\&. Default value means no exponential backoff is performed and reconnect interval calculations are only based on ZMQ_RECONNECT_IVL\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
Values less than ZMQ_RECONNECT_IVL will be ignored\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
0 (only use ZMQ_RECONNECT_IVL)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, only for connection\-oriented transports
T}
.TE
.sp 1
.SS "ZMQ_RECOVERY_IVL: Set multicast recovery interval"
.sp
The \fIZMQ_RECOVERY_IVL\fR option shall set the recovery interval for multicast transports using the specified \fIsocket\fR\&. The recovery interval determines the maximum time in milliseconds that a receiver can be absent from a multicast group before unrecoverable data loss will occur\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBCaution\fR
.ps -1
.br
.sp
Exercise care when setting large recovery intervals as the data needed for recovery will be held in memory\&. For example, a 1 minute recovery interval at a data rate of 1Gbps requires a 7GB in\-memory buffer\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
10000
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using multicast transports
T}
.TE
.sp 1
.SS "ZMQ_REQ_CORRELATE: match replies with requests"
.sp
The default behavior of REQ sockets is to rely on the ordering of messages to match requests and responses and that is usually sufficient\&. When this option is set to 1, the REQ socket will prefix outgoing messages with an extra frame containing a request id\&. That means the full message is (request id, 0, user frames\&...)\&. The REQ socket will discard all incoming messages that don\(cqt begin with these two frames\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_REQ
T}
.TE
.sp 1
.SS "ZMQ_REQ_RELAXED: relax strict alternation between request and reply"
.sp
By default, a REQ socket does not allow initiating a new request with \fIzmq_send(3)\fR until the reply to the previous one has been received\&. When set to 1, sending another message is allowed and has the effect of disconnecting the underlying connection to the peer from which the reply was expected, triggering a reconnection attempt on transports that support it\&. The request\-reply state machine is reset and a new request is sent to the next available peer\&.
.sp
If set to 1, also enable ZMQ_REQ_CORRELATE to ensure correct matching of requests and replies\&. Otherwise a late reply to an aborted request can be reported as the reply to the superseding request\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_REQ
T}
.TE
.sp 1
.SS "ZMQ_ROUTER_HANDOVER: handle duplicate client identities on ROUTER sockets"
.sp
If two clients use the same identity when connecting to a ROUTER, the results shall depend on the ZMQ_ROUTER_HANDOVER option setting\&. If that is not set (or set to the default of zero), the ROUTER socket shall reject clients trying to connect with an already\-used identity\&. If that option is set to 1, the ROUTER socket shall hand\-over the connection to the new client and disconnect the existing one\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_ROUTER
T}
.TE
.sp 1
.SS "ZMQ_ROUTER_MANDATORY: accept only routable messages on ROUTER sockets"
.sp
Sets the ROUTER socket behavior when an unroutable message is encountered\&. A value of 0 is the default and discards the message silently when it cannot be routed or the peers SNDHWM is reached\&. A value of 1 returns an \fIEHOSTUNREACH\fR error code if the message cannot be routed or \fIEAGAIN\fR error code if the SNDHWM is reached and ZMQ_DONTWAIT was used\&. Without ZMQ_DONTWAIT it will block until the SNDTIMEO is reached or a spot in the send queue opens up\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_ROUTER
T}
.TE
.sp 1
.SS "ZMQ_ROUTER_RAW: switch ROUTER socket to raw mode"
.sp
Sets the raw mode on the ROUTER, when set to 1\&. When the ROUTER socket is in raw mode, and when using the tcp:// transport, it will read and write TCP data without 0MQ framing\&. This lets 0MQ applications talk to non\-0MQ applications\&. When using raw mode, you cannot set explicit identities, and the ZMQ_SNDMORE flag is ignored when sending data messages\&. In raw mode you can close a specific connection by sending it a zero\-length message (following the identity frame)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
This option is deprecated, please use ZMQ_STREAM sockets instead\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_ROUTER
T}
.TE
.sp 1
.SS "ZMQ_SNDBUF: Set kernel transmit buffer size"
.sp
The \fIZMQ_SNDBUF\fR option shall set the underlying kernel transmit buffer size for the \fIsocket\fR to the specified size in bytes\&. A value of zero means leave the OS default unchanged\&. For details please refer to your operating system documentation for the \fISO_SNDBUF\fR socket option\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
bytes
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all
T}
.TE
.sp 1
.SS "ZMQ_SNDHWM: Set high water mark for outbound messages"
.sp
The \fIZMQ_SNDHWM\fR option shall set the high water mark for outbound messages on the specified \fIsocket\fR\&. The high water mark is a hard limit on the maximum number of outstanding messages 0MQ shall queue in memory for any single peer that the specified \fIsocket\fR is communicating with\&. A value of zero means no limit\&.
.sp
If this limit has been reached the socket shall enter an exceptional state and depending on the socket type, 0MQ shall take appropriate action such as blocking or dropping sent messages\&. Refer to the individual socket descriptions in \fBzmq_socket\fR(3) for details on the exact action taken for each socket type\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
0MQ does not guarantee that the socket will accept as many as ZMQ_SNDHWM messages, and the actual limit may be as much as 60\-70% lower depending on the flow of messages on the socket\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
messages
T}
T{
.sp
Default value
T}:T{
.sp
1000
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all
T}
.TE
.sp 1
.SS "ZMQ_SNDTIMEO: Maximum time before a send operation returns with EAGAIN"
.sp
Sets the timeout for send operation on the socket\&. If the value is 0, \fIzmq_send(3)\fR will return immediately, with a EAGAIN error if the message cannot be sent\&. If the value is \-1, it will block until the message is sent\&. For all other values, it will try to send the message for that amount of time before returning with an EAGAIN error\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
milliseconds
T}
T{
.sp
Default value
T}:T{
.sp
\-1 (infinite)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all
T}
.TE
.sp 1
.SS "ZMQ_SUBSCRIBE: Establish message filter"
.sp
The \fIZMQ_SUBSCRIBE\fR option shall establish a new message filter on a \fIZMQ_SUB\fR socket\&. Newly created \fIZMQ_SUB\fR sockets shall filter out all incoming messages, therefore you should call this option to establish an initial message filter\&.
.sp
An empty \fIoption_value\fR of length zero shall subscribe to all incoming messages\&. A non\-empty \fIoption_value\fR shall subscribe to all messages beginning with the specified prefix\&. Multiple filters may be attached to a single \fIZMQ_SUB\fR socket, in which case a message shall be accepted if it matches at least one filter\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
N/A
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_SUB
T}
.TE
.sp 1
.SS "ZMQ_TCP_KEEPALIVE: Override SO_KEEPALIVE socket option"
.sp
Override \fISO_KEEPALIVE\fR socket option (where supported by OS)\&. The default value of \-1 means to skip any overrides and leave it to OS default\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
\-1,0,1
T}
T{
.sp
Default value
T}:T{
.sp
\-1 (leave to OS default)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_TCP_KEEPALIVE_CNT: Override TCP_KEEPCNT socket option"
.sp
Override \fITCP_KEEPCNT\fR socket option (where supported by OS)\&. The default value of \-1 means to skip any overrides and leave it to OS default\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
\-1,>0
T}
T{
.sp
Default value
T}:T{
.sp
\-1 (leave to OS default)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_TCP_KEEPALIVE_IDLE: Override TCP_KEEPCNT (or TCP_KEEPALIVE on some OS)"
.sp
Override \fITCP_KEEPCNT\fR (or \fITCP_KEEPALIVE\fR on some OS) socket option (where supported by OS)\&. The default value of \-1 means to skip any overrides and leave it to OS default\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
\-1,>0
T}
T{
.sp
Default value
T}:T{
.sp
\-1 (leave to OS default)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_TCP_KEEPALIVE_INTVL: Override TCP_KEEPINTVL socket option"
.sp
Override \fITCP_KEEPINTVL\fR socket option(where supported by OS)\&. The default value of \-1 means to skip any overrides and leave it to OS default\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
\-1,>0
T}
T{
.sp
Default value
T}:T{
.sp
\-1 (leave to OS default)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_TOS: Set the Type\-of\-Service on socket"
.sp
Sets the ToS fields (Differentiated services (DS) and Explicit Congestion Notification (ECN) field of the IP header\&. The ToS field is typically used to specify a packets priority\&. The availability of this option is dependent on intermediate network equipment that inspect the ToS field andprovide a path for low\-delay, high\-throughput, highly\-reliable service, etc\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
>0
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, only for connection\-oriented transports
T}
.TE
.sp 1
.SS "ZMQ_UNSUBSCRIBE: Remove message filter"
.sp
The \fIZMQ_UNSUBSCRIBE\fR option shall remove an existing message filter on a \fIZMQ_SUB\fR socket\&. The filter specified must match an existing filter previously established with the \fIZMQ_SUBSCRIBE\fR option\&. If the socket has several instances of the same filter attached the \fIZMQ_UNSUBSCRIBE\fR option shall remove only one instance, leaving the rest in place and functional\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
N/A
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_SUB
T}
.TE
.sp 1
.SS "ZMQ_XPUB_VERBOSE: provide all subscription messages on XPUB sockets"
.sp
Sets the \fIXPUB\fR socket behavior on new subscriptions and unsubscriptions\&. A value of \fI0\fR is the default and passes only new subscription messages to upstream\&. A value of \fI1\fR passes all subscription messages upstream\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
0, 1
T}
T{
.sp
Default value
T}:T{
.sp
0
T}
T{
.sp
Applicable socket types
T}:T{
.sp
ZMQ_XPUB
T}
.TE
.sp 1
.SS "ZMQ_ZAP_DOMAIN: Set RFC 27 authentication domain"
.sp
Sets the domain for ZAP (ZMQ RFC 27) authentication\&. For NULL security (the default on all tcp:// connections), ZAP authentication only happens if you set a non\-empty domain\&. For PLAIN and CURVE security, ZAP requests are always made, if there is a ZAP handler present\&. See \m[blue]\fBhttp://rfc\&.zeromq\&.org/spec:27\fR\m[] for more details\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
character string
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
not set
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transport
T}
.TE
.sp 1
.SS "ZMQ_TCP_ACCEPT_FILTER: Assign filters to allow new TCP connections"
.sp
Assign an arbitrary number of filters that will be applied for each new TCP transport connection on a listening socket\&. If no filters are applied, then the TCP transport allows connections from any IP address\&. If at least one filter is applied then new connection source ip should be matched\&. To clear all filters call zmq_setsockopt(socket, ZMQ_TCP_ACCEPT_FILTER, NULL, 0)\&. Filter is a null\-terminated string with ipv6 or ipv4 CIDR\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
This option is deprecated, please use authentication via the ZAP API and IP address whitelisting / blacklisting\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
binary data
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
no filters (allow from all)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all listening sockets, when using TCP transports\&.
T}
.TE
.sp 1
.SS "ZMQ_IPC_FILTER_GID: Assign group ID filters to allow new IPC connections"
.sp
Assign an arbitrary number of filters that will be applied for each new IPC transport connection on a listening socket\&. If no IPC filters are applied, then the IPC transport allows connections from any process\&. If at least one UID, GID, or PID filter is applied then new connection credentials should be matched\&. To clear all GID filters call zmq_setsockopt(socket, ZMQ_IPC_FILTER_GID, NULL, 0)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
GID filters are only available on platforms supporting SO_PEERCRED or LOCAL_PEERCRED socket options (currently only Linux and later versions of OS X)\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
This option is deprecated, please use authentication via the ZAP API and IPC whitelisting / blacklisting\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
gid_t
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
no filters (allow from all)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all listening sockets, when using IPC transports\&.
T}
.TE
.sp 1
.SS "ZMQ_IPC_FILTER_PID: Assign process ID filters to allow new IPC connections"
.sp
Assign an arbitrary number of filters that will be applied for each new IPC transport connection on a listening socket\&. If no IPC filters are applied, then the IPC transport allows connections from any process\&. If at least one UID, GID, or PID filter is applied then new connection credentials should be matched\&. To clear all PID filters call zmq_setsockopt(socket, ZMQ_IPC_FILTER_PID, NULL, 0)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
PID filters are only available on platforms supporting the SO_PEERCRED socket option (currently only Linux)\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
This option is deprecated, please use authentication via the ZAP API and IPC whitelisting / blacklisting\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
pid_t
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
no filters (allow from all)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all listening sockets, when using IPC transports\&.
T}
.TE
.sp 1
.SS "ZMQ_IPC_FILTER_UID: Assign user ID filters to allow new IPC connections"
.sp
Assign an arbitrary number of filters that will be applied for each new IPC transport connection on a listening socket\&. If no IPC filters are applied, then the IPC transport allows connections from any process\&. If at least one UID, GID, or PID filter is applied then new connection credentials should be matched\&. To clear all UID filters call zmq_setsockopt(socket, ZMQ_IPC_FILTER_UID, NULL, 0)\&.
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
UID filters are only available on platforms supporting SO_PEERCRED or LOCAL_PEERCRED socket options (currently only Linux and later versions of OS X)\&.
.sp .5v
.RE
.if n \{\
.sp
.\}
.RS 4
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.ps +1
\fBNote\fR
.ps -1
.br
.sp
This option is deprecated, please use authentication via the ZAP API and IPC whitelisting / blacklisting\&.
.sp .5v
.RE
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
uid_t
T}
T{
.sp
Option value unit
T}:T{
.sp
N/A
T}
T{
.sp
Default value
T}:T{
.sp
no filters (allow from all)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all listening sockets, when using IPC transports\&.
T}
.TE
.sp 1
.SS "ZMQ_IPV4ONLY: Use IPv4\-only on socket"
.sp
Set the IPv4\-only option for the socket\&. This option is deprecated\&. Please use the ZMQ_IPV6 option\&.
.TS
tab(:);
lt lt
lt lt
lt lt
lt lt.
T{
.sp
Option value type
T}:T{
.sp
int
T}
T{
.sp
Option value unit
T}:T{
.sp
boolean
T}
T{
.sp
Default value
T}:T{
.sp
1 (true)
T}
T{
.sp
Applicable socket types
T}:T{
.sp
all, when using TCP transports\&.
T}
.TE
.sp 1
.SH "RETURN VALUE"
.sp
The \fIzmq_setsockopt()\fR function shall return zero if successful\&. Otherwise it shall return \-1 and set \fIerrno\fR to one of the values defined below\&.
.SH "ERRORS"
.PP
\fBEINVAL\fR
.RS 4
The requested option
\fIoption_name\fR
is unknown, or the requested
\fIoption_len\fR
or
\fIoption_value\fR
is invalid\&.
.RE
.PP
\fBETERM\fR
.RS 4
The 0MQ
\fIcontext\fR
associated with the specified
\fIsocket\fR
was terminated\&.
.RE
.PP
\fBENOTSOCK\fR
.RS 4
The provided
\fIsocket\fR
was invalid\&.
.RE
.PP
\fBEINTR\fR
.RS 4
The operation was interrupted by delivery of a signal\&.
.RE
.SH "EXAMPLE"
.PP
\fBSubscribing to messages on a ZMQ_SUB socket\fR. 
.sp
.if n \{\
.RS 4
.\}
.nf
/* Subscribe to all messages */
rc = zmq_setsockopt (socket, ZMQ_SUBSCRIBE, "", 0);
assert (rc == 0);
/* Subscribe to messages prefixed with "ANIMALS\&.CATS" */
rc = zmq_setsockopt (socket, ZMQ_SUBSCRIBE, "ANIMALS\&.CATS", 12);
.fi
.if n \{\
.RE
.\}
.PP
\fBSetting I/O thread affinity\fR. 
.sp
.if n \{\
.RS 4
.\}
.nf
int64_t affinity;
/* Incoming connections on TCP port 5555 shall be handled by I/O thread 1 */
affinity = 1;
rc = zmq_setsockopt (socket, ZMQ_AFFINITY, &affinity, sizeof (affinity));
assert (rc);
rc = zmq_bind (socket, "tcp://lo:5555");
assert (rc);
/* Incoming connections on TCP port 5556 shall be handled by I/O thread 2 */
affinity = 2;
rc = zmq_setsockopt (socket, ZMQ_AFFINITY, &affinity, sizeof (affinity));
assert (rc);
rc = zmq_bind (socket, "tcp://lo:5556");
assert (rc);
.fi
.if n \{\
.RE
.\}
.sp
.SH "SEE ALSO"
.sp
\fBzmq_getsockopt\fR(3) \fBzmq_socket\fR(3) \fBzmq_plain\fR(7) \fBzmq_curve\fR(7) \fBzmq\fR(7)
.SH "AUTHORS"
.sp
This page was written by the 0MQ community\&. To make a change please read the 0MQ Contribution Policy at \m[blue]\fBhttp://www\&.zeromq\&.org/docs:contributing\fR\m[]\&.
